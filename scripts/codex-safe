#!/bin/bash
# codex-safe: resilient wrapper for codex exec with project-local CODEX_HOME

set -euo pipefail

ROOT="/Users/array0224/stillframe-phase0"
CODEX_HOME="$ROOT/.rwl/codex-home"
CONFIG_PATH="$CODEX_HOME/config.toml"
LOG_DIR="$ROOT/.rwl/logs"
MAX_ATTEMPTS=8

NTFY_SERVER="${NTFY_SERVER:-https://ntfy.sh}"
NTFY_TOPIC="${NTFY_TOPIC:-shinen-a3138f616ac49f6db007e149d78872d4}"

mkdir -p "$CODEX_HOME" "$LOG_DIR"
export CODEX_HOME

notify() {
  local priority="$1"
  local title="$2"
  local message="$3"

  NTFY_SERVER="$NTFY_SERVER" NTFY_TOPIC="$NTFY_TOPIC" \
    node "$ROOT/tools/notify/ntfy.mjs" \
      --title "$title" \
      --message "$message" \
      --priority "$priority" >/dev/null 2>&1 || true
}

truncate_for_notify() {
  local input="$1"
  local max=800
  local head_len=520
  local tail_len=220

  if [ "${#input}" -le "$max" ]; then
    printf '%s' "$input"
    return
  fi

  printf '%s\n...\n%s' "${input:0:$head_len}" "${input: -$tail_len}"
}

set_root_key() {
  local key="$1"
  local value="$2"
  local tmp
  tmp="$(mktemp)"

  awk -v k="$key" -v v="$value" '
    BEGIN {
      re = "^[[:space:]]*" k "[[:space:]]*="
      done = 0
    }
    $0 ~ re {
      if (!done) {
        print k " = " v
        done = 1
      }
      next
    }
    { print }
    END {
      if (!done) print k " = " v
    }
  ' "$CONFIG_PATH" > "$tmp"

  mv "$tmp" "$CONFIG_PATH"
}

set_provider_field() {
  local field="$1"
  local value="$2"
  local tmp
  tmp="$(mktemp)"

  awk -v f="$field" -v v="$value" '
    BEGIN {
      in_section = 0
      replaced = 0
      re = "^[[:space:]]*" f "[[:space:]]*="
    }
    {
      if ($0 ~ /^\[/) {
        if (in_section && !replaced) {
          print f " = " v
          replaced = 1
        }
        in_section = ($0 == "[model_providers.openai]")
        print
        next
      }

      if (in_section && $0 ~ re) {
        if (!replaced) {
          print f " = " v
          replaced = 1
        }
        next
      }

      print
    }
    END {
      if (in_section && !replaced) {
        print f " = " v
      }
    }
  ' "$CONFIG_PATH" > "$tmp"

  mv "$tmp" "$CONFIG_PATH"
}

ensure_config() {
  if [ ! -f "$CONFIG_PATH" ]; then
    cat > "$CONFIG_PATH" <<'TOML'
model_provider = "openai"
approval_policy = "never"
sandbox_mode = "workspace-write"
cli_auth_credentials_store = "file"

[sandbox_workspace_write]
network_access = true

[model_providers.openai]
name = "OpenAI"
requires_openai_auth = true
request_max_retries = 10
stream_max_retries = 25
stream_idle_timeout_ms = 900000
TOML
  fi

  set_root_key "model_provider" '"openai"'
  set_root_key "approval_policy" '"never"'
  set_root_key "sandbox_mode" '"workspace-write"'
  set_root_key "cli_auth_credentials_store" '"file"'

  if ! grep -q '^\[sandbox_workspace_write\]' "$CONFIG_PATH"; then
    cat >> "$CONFIG_PATH" <<'TOML'

[sandbox_workspace_write]
network_access = true
TOML
  fi

  if ! grep -q '^\[model_providers\.openai\]' "$CONFIG_PATH"; then
    cat >> "$CONFIG_PATH" <<'TOML'

[model_providers.openai]
name = "OpenAI"
requires_openai_auth = true
request_max_retries = 10
stream_max_retries = 25
stream_idle_timeout_ms = 900000
TOML
  fi

  set_provider_field "name" '"OpenAI"'
  set_provider_field "requires_openai_auth" "true"
  set_provider_field "request_max_retries" "10"
  set_provider_field "stream_max_retries" "25"
  set_provider_field "stream_idle_timeout_ms" "900000"
}

auth_ok() {
  (cd "$ROOT" && codex login status >/dev/null 2>&1)
}

ensure_auth() {
  ensure_config

  if auth_ok; then
    return 0
  fi

  if [ -f "$HOME/.codex/auth.json" ]; then
    cp "$HOME/.codex/auth.json" "$CODEX_HOME/auth.json"
    chmod 600 "$CODEX_HOME/auth.json"
    if auth_ok; then
      return 0
    fi
  fi

  if [ -n "${OPENAI_API_KEY:-}" ]; then
    if printenv OPENAI_API_KEY | (cd "$ROOT" && codex login --with-api-key >/dev/null 2>&1); then
      if auth_ok; then
        return 0
      fi
    fi
  fi

  local device_log
  device_log="$(cd "$ROOT" && codex login --device-auth 2>&1 || true)"
  local clipped
  clipped="$(truncate_for_notify "$device_log")"
  notify "4" "üîê Codex login required" "$clipped"

  local max_wait=300
  local i=0
  while [ "$i" -lt "$max_wait" ]; do
    if auth_ok; then
      notify "3" "‚úÖ Codex login OK" "Device auth completed for codex-safe"
      return 0
    fi
    sleep 2
    i=$((i + 1))
  done

  notify "4" "‚ùå Codex login timeout" "codex login status did not become ready within 10 minutes"
  return 2
}

PROMPT="$*"
if [ -z "$PROMPT" ]; then
  echo "Usage: $0 <prompt>" >&2
  exit 1
fi

if ! ensure_auth; then
  echo "[FATAL] Codex authentication is not ready." >&2
  exit 2
fi

attempt=1
backoff=1
reauth_on_401_done=0

while [ "$attempt" -le "$MAX_ATTEMPTS" ]; do
  echo "=== Attempt $attempt/$MAX_ATTEMPTS (backoff: ${backoff}s) ===" >&2

  output_log="$LOG_DIR/codex-safe-attempt-${attempt}.log"
  set +e
  (cd "$ROOT" && codex exec "$PROMPT") 2>&1 | tee "$output_log"
  exit_code=${PIPESTATUS[0]}
  set -e

  if [ "$exit_code" -eq 0 ]; then
    notify "3" "‚úÖ Codex Success" "Task completed (attempt $attempt/$MAX_ATTEMPTS)"
    echo "SUCCESS: Task completed on attempt $attempt" >&2
    exit 0
  fi

  if grep -Eiq '401 Unauthorized|Missing bearer or basic authentication' "$output_log"; then
    echo "Detected auth failure (401). Running one-time auth bootstrap." >&2
    if [ "$reauth_on_401_done" -eq 0 ]; then
      reauth_on_401_done=1
      if ensure_auth; then
        continue
      fi
      notify "4" "‚ùå Codex Failed" "Authentication bootstrap failed after 401"
      exit 2
    fi
  fi

  echo "FAILED: Attempt $attempt failed with exit code $exit_code" >&2

  if grep -Eiq 'stream.*disconnect|connection.*reset|timeout' "$output_log"; then
    echo "Detected stream disconnect ‚Äî attempting resume" >&2
    resume_log="$LOG_DIR/codex-safe-resume-${attempt}.log"

    set +e
    (cd "$ROOT" && codex exec resume --last "continue") 2>&1 | tee "$resume_log"
    resume_code=${PIPESTATUS[0]}
    set -e

    if [ "$resume_code" -eq 0 ]; then
      notify "3" "‚úÖ Codex Recovered" "Task recovered after stream disconnect (attempt $attempt)"
      echo "SUCCESS: Recovered via resume on attempt $attempt" >&2
      exit 0
    fi

    echo "Resume failed with exit code $resume_code" >&2
  fi

  if [ "$attempt" -ge "$MAX_ATTEMPTS" ]; then
    notify "4" "‚ùå Codex Failed" "Task failed after $MAX_ATTEMPTS attempts"
    echo "FAILURE: All $MAX_ATTEMPTS attempts exhausted" >&2
    exit 1
  fi

  sleep "$backoff"
  backoff=$((backoff * 2))
  if [ "$backoff" -gt 16 ]; then
    backoff=16
  fi

  attempt=$((attempt + 1))
done

notify "4" "‚ùå Codex Failed" "Unexpected loop exit"
exit 1
