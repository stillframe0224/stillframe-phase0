name: automerge-safe

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened, ready_for_review, labeled, unlabeled]
  workflow_run:
    workflows: [e2e, stage3, deploy-smoke, ui-smoke]
    types: [completed]
  schedule:
    - cron: '17 * * * *'

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: automerge-safe-${{ github.event.pull_request.number || github.event.workflow_run.id || 'sweep' }}
  cancel-in-progress: true

jobs:
  automerge:
    name: automerge-safe
    if: >-
      github.event_name != 'schedule'
      && (
        (github.event_name == 'pull_request'
         && github.event.pull_request.draft == false
         && github.event.pull_request.head.repo.full_name == github.repository)
        ||
        (github.event_name == 'workflow_run'
         && github.event.workflow_run.conclusion == 'success'
         && github.event.workflow_run.event == 'pull_request')
      )
    runs-on: ubuntu-latest
    steps:
      - name: Resolve PR number
        id: resolve
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            let prNumber = null;
            let prData = null;

            if (context.eventName === 'pull_request') {
              prNumber = context.payload.pull_request.number;
            } else {
              // workflow_run: find associated PR
              const prs = context.payload.workflow_run.pull_requests || [];
              if (prs.length > 0) {
                prNumber = prs[0].number;
              } else {
                // fallback: find open PR by head_sha
                const headSha = context.payload.workflow_run.head_sha;
                const headBranch = context.payload.workflow_run.head_branch;
                core.info(`No pull_requests in payload; searching by branch=${headBranch} sha=${headSha}`);
                const { data: pulls } = await github.rest.pulls.list({
                  owner, repo,
                  state: 'open',
                  head: `${owner}:${headBranch}`,
                  per_page: 5,
                });
                if (pulls.length > 0) {
                  prNumber = pulls[0].number;
                }
              }
            }

            if (!prNumber) {
              core.info('No associated PR found; exiting safely.');
              core.setOutput('skip', 'true');
              return;
            }

            // Fetch full PR data for safety checks
            const { data: pr } = await github.rest.pulls.get({
              owner, repo,
              pull_number: prNumber,
            });

            if (pr.draft) {
              core.info(`PR #${prNumber} is draft; skipping.`);
              core.setOutput('skip', 'true');
              return;
            }
            if (pr.head.repo.full_name !== `${owner}/${repo}`) {
              core.info(`PR #${prNumber} is from fork; skipping.`);
              core.setOutput('skip', 'true');
              return;
            }
            if (pr.state !== 'open') {
              core.info(`PR #${prNumber} is ${pr.state}; skipping.`);
              core.setOutput('skip', 'true');
              return;
            }

            core.setOutput('skip', 'false');
            core.setOutput('pr_number', String(prNumber));
            core.setOutput('pr_title', pr.title);
            core.setOutput('pr_labels', JSON.stringify(pr.labels.map(l => l.name)));

      - name: Classify changed files
        if: steps.resolve.outputs.skip != 'true'
        id: classify
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = parseInt('${{ steps.resolve.outputs.pr_number }}', 10);
            const prTitle = `${{ steps.resolve.outputs.pr_title }}`;
            const labels = JSON.parse('${{ steps.resolve.outputs.pr_labels }}');

            // --- Kill switches ---
            if (labels.includes('automerge:off')) {
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'Kill switch label "automerge:off" present');
              return;
            }
            if (prTitle.includes('[NO-AUTOMERGE]')) {
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'PR title contains [NO-AUTOMERGE]');
              return;
            }

            // --- Gather all changed files (paginated) ---
            const files = [];
            for (let page = 1; ; page++) {
              const resp = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: 100,
                page,
              });
              files.push(...resp.data.map(f => f.filename));
              if (resp.data.length < 100) break;
            }

            core.setOutput('files', files.join('\n'));
            core.setOutput('pr_number_out', String(prNumber));

            // --- Deny patterns (checked first) ---
            const denyPatterns = [
              /^\.github\/workflows\//,
              /^pnpm-lock\.yaml$/,
              /^package-lock\.json$/,
              /^yarn\.lock$/,
              /^app\//,
              /^lib\//,
              /^scripts\//,
              /^api\//,
            ];

            for (const f of files) {
              for (const pattern of denyPatterns) {
                if (pattern.test(f)) {
                  core.setOutput('eligible', 'false');
                  core.setOutput('reason', `Denied by file: ${f}`);
                  return;
                }
              }
            }

            // --- Allow patterns (every file must match one) ---
            const allowPatterns = [
              /^docs\//,
              /^ops\//,
              /^\.github\/(?!workflows\/)/,
              /\.md$/,
              /\.txt$/,
              /\.css$/,
            ];

            for (const f of files) {
              const allowed = allowPatterns.some(p => p.test(f));
              if (!allowed) {
                core.setOutput('eligible', 'false');
                core.setOutput('reason', `File not in allowlist: ${f}`);
                return;
              }
            }

            core.setOutput('eligible', 'true');
            core.setOutput('reason', 'All files in safe allowlist');

      - name: Write job summary
        if: steps.resolve.outputs.skip != 'true'
        run: |
          PR_NUM="${{ steps.classify.outputs.pr_number_out || steps.resolve.outputs.pr_number }}"
          cat >> "$GITHUB_STEP_SUMMARY" <<EOF
          ## automerge-safe classification

          | Field | Value |
          |-------|-------|
          | **Eligible** | \`${{ steps.classify.outputs.eligible }}\` |
          | **Reason** | ${{ steps.classify.outputs.reason }} |
          | **PR** | #${PR_NUM} |
          | **Trigger** | ${{ github.event_name }} |

          <details><summary>Changed files</summary>

          \`\`\`
          ${{ steps.classify.outputs.files }}
          \`\`\`

          </details>
          EOF

      - name: Add label if eligible
        if: steps.resolve.outputs.skip != 'true' && steps.classify.outputs.eligible == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = parseInt('${{ steps.resolve.outputs.pr_number }}', 10);
            const labelName = 'automerge:eligible';
            const labelColor = 'c2e0c6';  // neutral green

            // Ensure label exists
            try {
              await github.rest.issues.getLabel({ owner, repo, name: labelName });
            } catch (e) {
              if (e.status === 404) {
                await github.rest.issues.createLabel({
                  owner, repo,
                  name: labelName,
                  color: labelColor,
                  description: 'Safe-only automerge eligible',
                });
              }
            }

            await github.rest.issues.addLabels({
              owner, repo,
              issue_number: prNumber,
              labels: [labelName],
            });

      - name: Attempt automerge
        if: steps.resolve.outputs.skip != 'true' && steps.classify.outputs.eligible == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ steps.resolve.outputs.pr_number }}
        run: |
          set -euo pipefail

          REPO="${{ github.repository }}"
          AUTO_MERGE=$(gh api "repos/${REPO}" --jq '.allow_auto_merge // false')

          echo "allow_auto_merge=${AUTO_MERGE}"

          if [ "$AUTO_MERGE" = "true" ]; then
            echo "Repo has auto-merge enabled; enabling auto-merge on PR."
            gh pr merge "$PR_NUMBER" --repo "$REPO" --auto --squash --delete-branch || {
              echo "::warning::gh pr merge --auto failed; not falling back to admin merge."
              exit 0
            }
          else
            echo "Auto-merge not enabled on repo; checking merge state."
            STATE=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json mergeStateStatus --jq '.mergeStateStatus')
            echo "mergeStateStatus=${STATE}"
            if [ "$STATE" = "CLEAN" ]; then
              echo "PR is CLEAN; merging now."
              gh pr merge "$PR_NUMBER" --repo "$REPO" --squash --delete-branch || {
                echo "::warning::gh pr merge failed; not falling back to admin merge."
                exit 0
              }
            else
              echo "PR is not CLEAN (state=${STATE}); skipping merge. Will retry on next event."
              exit 0
            fi
          fi

  sweep-eligible:
    name: sweep-eligible
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - name: Sweep eligible PRs
        id: sweep
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Find open PRs with automerge:eligible label
            const { data: prs } = await github.rest.issues.listForRepo({
              owner, repo,
              state: 'open',
              labels: 'automerge:eligible',
              per_page: 20,
            });

            const candidates = prs.filter(p => p.pull_request);
            core.info(`Found ${candidates.length} open PRs with automerge:eligible label`);

            const results = [];

            for (const issue of candidates) {
              const prNumber = issue.number;

              // Fetch full PR data
              const { data: pr } = await github.rest.pulls.get({
                owner, repo,
                pull_number: prNumber,
              });

              // Safety checks
              if (pr.draft) {
                results.push({ pr: prNumber, action: 'skipped', reason: 'draft' });
                continue;
              }
              if (pr.head.repo.full_name !== `${owner}/${repo}`) {
                results.push({ pr: prNumber, action: 'skipped', reason: 'fork' });
                continue;
              }

              // Kill switches
              const labels = pr.labels.map(l => l.name);
              if (labels.includes('automerge:off')) {
                results.push({ pr: prNumber, action: 'skipped', reason: 'automerge:off' });
                continue;
              }
              if (pr.title.includes('[NO-AUTOMERGE]')) {
                results.push({ pr: prNumber, action: 'skipped', reason: '[NO-AUTOMERGE]' });
                continue;
              }

              // Re-validate allowlist/denylist
              const files = [];
              for (let page = 1; ; page++) {
                const resp = await github.rest.pulls.listFiles({
                  owner, repo,
                  pull_number: prNumber,
                  per_page: 100,
                  page,
                });
                files.push(...resp.data.map(f => f.filename));
                if (resp.data.length < 100) break;
              }

              const denyPatterns = [
                /^\.github\/workflows\//,
                /^pnpm-lock\.yaml$/,
                /^package-lock\.json$/,
                /^yarn\.lock$/,
                /^app\//,
                /^lib\//,
                /^scripts\//,
                /^api\//,
              ];

              let denied = false;
              for (const f of files) {
                for (const pattern of denyPatterns) {
                  if (pattern.test(f)) {
                    denied = true;
                    results.push({ pr: prNumber, action: 'skipped', reason: `denied: ${f}` });
                    break;
                  }
                }
                if (denied) break;
              }
              if (denied) continue;

              const allowPatterns = [
                /^docs\//,
                /^ops\//,
                /^\.github\/(?!workflows\/)/,
                /\.md$/,
                /\.txt$/,
                /\.css$/,
              ];

              let notAllowed = false;
              for (const f of files) {
                if (!allowPatterns.some(p => p.test(f))) {
                  notAllowed = true;
                  results.push({ pr: prNumber, action: 'skipped', reason: `not allowed: ${f}` });
                  break;
                }
              }
              if (notAllowed) continue;

              // Check merge state
              if (pr.mergeable_state === 'clean') {
                core.info(`PR #${prNumber} is CLEAN; attempting merge.`);
                try {
                  await github.rest.pulls.merge({
                    owner, repo,
                    pull_number: prNumber,
                    merge_method: 'squash',
                  });
                  results.push({ pr: prNumber, action: 'merged', reason: 'CLEAN' });

                  // Delete branch after merge
                  try {
                    await github.rest.git.deleteRef({
                      owner, repo,
                      ref: `heads/${pr.head.ref}`,
                    });
                  } catch (e) {
                    core.info(`Failed to delete branch ${pr.head.ref}: ${e.message}`);
                  }
                } catch (e) {
                  results.push({ pr: prNumber, action: 'failed', reason: e.message });
                }
              } else {
                results.push({ pr: prNumber, action: 'skipped', reason: `state=${pr.mergeable_state}` });
              }
            }

            // Set outputs for summary
            const merged = results.filter(r => r.action === 'merged').length;
            const skipped = results.filter(r => r.action === 'skipped').length;
            const failed = results.filter(r => r.action === 'failed').length;

            core.setOutput('candidates', String(candidates.length));
            core.setOutput('merged', String(merged));
            core.setOutput('skipped', String(skipped));
            core.setOutput('failed', String(failed));
            core.setOutput('details', JSON.stringify(results));

      - name: Write sweep summary
        run: |
          cat >> "$GITHUB_STEP_SUMMARY" <<EOF
          ## automerge-safe sweep

          | Metric | Count |
          |--------|-------|
          | **Candidates** | ${{ steps.sweep.outputs.candidates }} |
          | **Merged** | ${{ steps.sweep.outputs.merged }} |
          | **Skipped** | ${{ steps.sweep.outputs.skipped }} |
          | **Failed** | ${{ steps.sweep.outputs.failed }} |

          <details><summary>Details</summary>

          \`\`\`json
          ${{ steps.sweep.outputs.details }}
          \`\`\`

          </details>
          EOF
