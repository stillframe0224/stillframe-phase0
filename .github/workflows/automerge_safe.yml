name: automerge-safe

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened, ready_for_review, labeled, unlabeled]
  workflow_run:
    workflows: [e2e, stage3, deploy-smoke, ui-smoke]
    types: [completed]
  schedule:
    - cron: '17 * * * *'

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  REQUIRED_CHECKS: |
    audit
    build
    guard
    smoke
    ui-smoke
    deploy-smoke
    codex-review-check
    codex-headings-unit

concurrency:
  group: automerge-safe-${{ github.event.pull_request.number || github.event.workflow_run.id || 'sweep' }}
  cancel-in-progress: true

jobs:
  automerge:
    name: automerge-safe
    if: >-
      github.event_name != 'schedule'
      && (
        (github.event_name == 'pull_request'
         && github.event.pull_request.draft == false
         && github.event.pull_request.head.repo.full_name == github.repository)
        ||
        (github.event_name == 'workflow_run'
         && github.event.workflow_run.conclusion == 'success'
         && github.event.workflow_run.event == 'pull_request')
      )
    runs-on: ubuntu-latest
    steps:
      - name: Global kill switch gate
        id: gate
        env:
          DISABLED: ${{ vars.AUTOMERGE_GLOBAL_OFF == '1' }}
        run: |
          echo "disabled=$DISABLED" >> "$GITHUB_OUTPUT"
          if [ "$DISABLED" = "true" ]; then
            echo "## automerge-safe: DISABLED" >> "$GITHUB_STEP_SUMMARY"
            echo "Global kill switch enabled (\`AUTOMERGE_GLOBAL_OFF=1\`). All automerge actions skipped." >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Resolve PR number
        if: steps.gate.outputs.disabled != 'true'
        id: resolve
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            let prNumber = null;
            let prData = null;

            if (context.eventName === 'pull_request') {
              prNumber = context.payload.pull_request.number;
            } else {
              // workflow_run: find associated PR
              const prs = context.payload.workflow_run.pull_requests || [];
              if (prs.length > 0) {
                prNumber = prs[0].number;
              } else {
                // fallback: find open PR by head_sha
                const headSha = context.payload.workflow_run.head_sha;
                const headBranch = context.payload.workflow_run.head_branch;
                core.info(`No pull_requests in payload; searching by branch=${headBranch} sha=${headSha}`);
                const { data: pulls } = await github.rest.pulls.list({
                  owner, repo,
                  state: 'open',
                  head: `${owner}:${headBranch}`,
                  per_page: 5,
                });
                if (pulls.length > 0) {
                  prNumber = pulls[0].number;
                }
              }
            }

            if (!prNumber) {
              core.info('No associated PR found; exiting safely.');
              core.setOutput('skip', 'true');
              return;
            }

            // Fetch full PR data for safety checks
            const { data: pr } = await github.rest.pulls.get({
              owner, repo,
              pull_number: prNumber,
            });

            if (pr.draft) {
              core.info(`PR #${prNumber} is draft; skipping.`);
              core.setOutput('skip', 'true');
              return;
            }
            if (pr.head.repo.full_name !== `${owner}/${repo}`) {
              core.info(`PR #${prNumber} is from fork; skipping.`);
              core.setOutput('skip', 'true');
              return;
            }
            if (pr.state !== 'open') {
              core.info(`PR #${prNumber} is ${pr.state}; skipping.`);
              core.setOutput('skip', 'true');
              return;
            }

            core.setOutput('skip', 'false');
            core.setOutput('pr_number', String(prNumber));
            core.setOutput('pr_title', pr.title);
            core.setOutput('pr_labels', JSON.stringify(pr.labels.map(l => l.name)));

      - name: Classify changed files
        if: steps.gate.outputs.disabled != 'true' && steps.resolve.outputs.skip != 'true'
        id: classify
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = parseInt('${{ steps.resolve.outputs.pr_number }}', 10);
            const prTitle = `${{ steps.resolve.outputs.pr_title }}`;
            const labels = JSON.parse('${{ steps.resolve.outputs.pr_labels }}');

            // --- Kill switches ---
            if (labels.includes('automerge:off')) {
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'Kill switch label "automerge:off" present');
              return;
            }
            if (prTitle.includes('[NO-AUTOMERGE]')) {
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'PR title contains [NO-AUTOMERGE]');
              return;
            }

            // --- Gather all changed files (paginated) ---
            const files = [];
            for (let page = 1; ; page++) {
              const resp = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: 100,
                page,
              });
              files.push(...resp.data.map(f => f.filename));
              if (resp.data.length < 100) break;
            }

            core.setOutput('files', files.join('\n'));
            core.setOutput('pr_number_out', String(prNumber));

            // --- Deny patterns (checked first, hard stop) ---
            const denyPatterns = [
              /^\.github\/workflows\//,
              /^\.github\/CODEOWNERS$/,
              /^\.github\/dependabot\.ya?ml$/,
              /^pnpm-lock\.yaml$/,
              /^package-lock\.json$/,
              /^yarn\.lock$/,
              /^package\.json$/,
              /^vercel\.json$/,
              /^app\//,
              /^lib\//,
              /^scripts\//,
              /^api\//,
            ];

            for (const f of files) {
              for (const pattern of denyPatterns) {
                if (pattern.test(f)) {
                  core.setOutput('eligible', 'false');
                  core.setOutput('reason', `Denied by file: ${f}`);
                  return;
                }
              }
            }

            // --- Allowlist v1.1 (extension-constrained) ---
            const docsExts = /\.(md|mdx|txt|css|json|ya?ml|svg|png|jpe?g|gif)$/;
            const opsExts = /\.(md|mdx|txt|json|ya?ml)$/;
            const rootExts = /\.(md|txt|css)$/;

            function isAllowed(f) {
              // A) docs/** with docs-safe extensions
              if (f.startsWith('docs/') && docsExts.test(f)) return true;
              // A) OPS/** or ops/** with ops-safe extensions
              if (/^[Oo][Pp][Ss]\//i.test(f) && opsExts.test(f)) return true;
              // A) reports/triad/**/*.md
              if (f.startsWith('reports/triad/') && f.endsWith('.md')) return true;
              // B) Any *.md, *.txt, *.css anywhere (covers root README, CHANGELOG, etc.)
              if (rootExts.test(f)) return true;
              // C) .github — only templates and markdown
              if (f.startsWith('.github/ISSUE_TEMPLATE/')) return true;
              if (f === '.github/PULL_REQUEST_TEMPLATE.md') return true;
              if (f.startsWith('.github/') && f.endsWith('.md') && !f.includes('/workflows/')) return true;
              return false;
            }

            for (const f of files) {
              if (!isAllowed(f)) {
                core.setOutput('eligible', 'false');
                core.setOutput('reason', `File not in allowlist: ${f}`);
                return;
              }
            }

            core.setOutput('eligible', 'true');
            core.setOutput('reason', 'All files in safe allowlist (v1.1)');

      - name: Write job summary
        if: steps.gate.outputs.disabled != 'true' && steps.resolve.outputs.skip != 'true'
        run: |
          PR_NUM="${{ steps.classify.outputs.pr_number_out || steps.resolve.outputs.pr_number }}"
          cat >> "$GITHUB_STEP_SUMMARY" <<EOF
          ## automerge-safe classification

          | Field | Value |
          |-------|-------|
          | **Eligible** | \`${{ steps.classify.outputs.eligible }}\` |
          | **Reason** | ${{ steps.classify.outputs.reason }} |
          | **PR** | #${PR_NUM} |
          | **Trigger** | ${{ github.event_name }} |

          <details><summary>Changed files</summary>

          \`\`\`
          ${{ steps.classify.outputs.files }}
          \`\`\`

          </details>
          EOF

      - name: Add label if eligible
        if: steps.gate.outputs.disabled != 'true' && steps.resolve.outputs.skip != 'true' && steps.classify.outputs.eligible == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = parseInt('${{ steps.resolve.outputs.pr_number }}', 10);
            const labelName = 'automerge:eligible';
            const labelColor = 'c2e0c6';  // neutral green

            // Ensure label exists
            try {
              await github.rest.issues.getLabel({ owner, repo, name: labelName });
            } catch (e) {
              if (e.status === 404) {
                await github.rest.issues.createLabel({
                  owner, repo,
                  name: labelName,
                  color: labelColor,
                  description: 'Safe-only automerge eligible',
                });
              }
            }

            await github.rest.issues.addLabels({
              owner, repo,
              issue_number: prNumber,
              labels: [labelName],
            });

      - name: Verify required checks (hard gate)
        if: steps.gate.outputs.disabled != 'true' && steps.resolve.outputs.skip != 'true' && steps.classify.outputs.eligible == 'true'
        id: checks
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"
          PR_NUMBER="${{ steps.resolve.outputs.pr_number }}"

          RESULT=$(gh api graphql -f query='
            query($owner:String!, $repo:String!, $number:Int!) {
              repository(owner:$owner, name:$repo) {
                pullRequest(number:$number) {
                  commits(last:1) {
                    nodes {
                      commit {
                        statusCheckRollup {
                          contexts(first:100) {
                            nodes {
                              __typename
                              ... on CheckRun { name status conclusion }
                              ... on StatusContext { context state }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }' -f owner="$OWNER" -f repo="$REPO_NAME" -F number="$PR_NUMBER")

          CONTEXTS=$(echo "$RESULT" | jq -c '.data.repository.pullRequest.commits.nodes[0].commit.statusCheckRollup.contexts.nodes // []')

          MISSING=""
          FAILED=""
          ALL_OK=true

          while IFS= read -r name; do
            [ -z "$name" ] && continue
            CHECK=$(echo "$CONTEXTS" | jq -r --arg n "$name" '[.[] | select(.__typename=="CheckRun" and .name==$n)] | last')
            if [ "$CHECK" != "null" ] && [ -n "$CHECK" ]; then
              STATUS=$(echo "$CHECK" | jq -r '.status')
              CONCLUSION=$(echo "$CHECK" | jq -r '.conclusion')
              if [ "$STATUS" != "COMPLETED" ] || [ "$CONCLUSION" != "SUCCESS" ]; then
                FAILED="$FAILED $name($STATUS/$CONCLUSION)"
                ALL_OK=false
              fi
              continue
            fi
            CTX=$(echo "$CONTEXTS" | jq -r --arg n "$name" '[.[] | select(.__typename=="StatusContext" and .context==$n)] | last')
            if [ "$CTX" != "null" ] && [ -n "$CTX" ]; then
              STATE=$(echo "$CTX" | jq -r '.state')
              if [ "$STATE" != "SUCCESS" ]; then
                FAILED="$FAILED $name($STATE)"
                ALL_OK=false
              fi
              continue
            fi
            MISSING="$MISSING $name"
            ALL_OK=false
          done <<< "$(echo "$REQUIRED_CHECKS" | tr -s '[:space:]' '\n' | grep -v '^$')"

          echo "checks_ok=$ALL_OK" >> "$GITHUB_OUTPUT"

          {
            echo "## Required checks gate"
            echo ""
            echo "| Check | Status |"
            echo "|-------|--------|"
            while IFS= read -r name; do
              [ -z "$name" ] && continue
              CHECK=$(echo "$CONTEXTS" | jq -r --arg n "$name" '[.[] | select(.__typename=="CheckRun" and .name==$n)] | last')
              if [ "$CHECK" != "null" ] && [ -n "$CHECK" ]; then
                S=$(echo "$CHECK" | jq -r '.status')
                C=$(echo "$CHECK" | jq -r '.conclusion')
                if [ "$S" = "COMPLETED" ] && [ "$C" = "SUCCESS" ]; then
                  echo "| $name | :white_check_mark: SUCCESS |"
                else
                  echo "| $name | :x: $S/$C |"
                fi
                continue
              fi
              CTX=$(echo "$CONTEXTS" | jq -r --arg n "$name" '[.[] | select(.__typename=="StatusContext" and .context==$n)] | last')
              if [ "$CTX" != "null" ] && [ -n "$CTX" ]; then
                ST=$(echo "$CTX" | jq -r '.state')
                if [ "$ST" = "SUCCESS" ]; then
                  echo "| $name | :white_check_mark: SUCCESS |"
                else
                  echo "| $name | :x: $ST |"
                fi
                continue
              fi
              echo "| $name | :warning: MISSING |"
            done <<< "$(echo "$REQUIRED_CHECKS" | tr -s '[:space:]' '\n' | grep -v '^$')"
            echo ""
            if [ "$ALL_OK" = "true" ]; then
              echo "**Result: ALL PASS** — merge eligible"
            else
              echo "**Result: BLOCKED**"
              [ -n "$MISSING" ] && echo "- Missing:$MISSING"
              [ -n "$FAILED" ] && echo "- Non-success:$FAILED"
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Attempt automerge
        if: steps.gate.outputs.disabled != 'true' && steps.resolve.outputs.skip != 'true' && steps.classify.outputs.eligible == 'true' && steps.checks.outputs.checks_ok == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ steps.resolve.outputs.pr_number }}
        run: |
          set -euo pipefail

          REPO="${{ github.repository }}"
          AUTO_MERGE=$(gh api "repos/${REPO}" --jq '.allow_auto_merge // false')

          echo "allow_auto_merge=${AUTO_MERGE}"

          if [ "$AUTO_MERGE" = "true" ]; then
            echo "Repo has auto-merge enabled; enabling auto-merge on PR."
            gh pr merge "$PR_NUMBER" --repo "$REPO" --auto --squash --delete-branch || {
              echo "::warning::gh pr merge --auto failed; not falling back to admin merge."
              exit 0
            }
          else
            echo "Auto-merge not enabled on repo; checking merge state."
            STATE=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json mergeStateStatus --jq '.mergeStateStatus')
            echo "mergeStateStatus=${STATE}"
            if [ "$STATE" = "CLEAN" ]; then
              echo "PR is CLEAN; merging now."
              gh pr merge "$PR_NUMBER" --repo "$REPO" --squash --delete-branch || {
                echo "::warning::gh pr merge failed; not falling back to admin merge."
                exit 0
              }
            else
              echo "PR is not CLEAN (state=${STATE}); skipping merge. Will retry on next event."
              exit 0
            fi
          fi

  sweep-eligible:
    name: sweep-eligible
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - name: Global kill switch gate
        id: gate
        env:
          DISABLED: ${{ vars.AUTOMERGE_GLOBAL_OFF == '1' }}
        run: |
          echo "disabled=$DISABLED" >> "$GITHUB_OUTPUT"
          if [ "$DISABLED" = "true" ]; then
            echo "## sweep-eligible: DISABLED" >> "$GITHUB_STEP_SUMMARY"
            echo "Global kill switch enabled (\`AUTOMERGE_GLOBAL_OFF=1\`). Sweep skipped." >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Sweep eligible PRs
        if: steps.gate.outputs.disabled != 'true'
        id: sweep
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Find open PRs with automerge:eligible label
            const { data: prs } = await github.rest.issues.listForRepo({
              owner, repo,
              state: 'open',
              labels: 'automerge:eligible',
              per_page: 20,
            });

            const candidates = prs.filter(p => p.pull_request);
            core.info(`Found ${candidates.length} open PRs with automerge:eligible label`);

            const results = [];

            for (const issue of candidates) {
              const prNumber = issue.number;

              // Fetch full PR data
              const { data: pr } = await github.rest.pulls.get({
                owner, repo,
                pull_number: prNumber,
              });

              // Safety checks
              if (pr.draft) {
                results.push({ pr: prNumber, action: 'skipped', reason: 'draft' });
                continue;
              }
              if (pr.head.repo.full_name !== `${owner}/${repo}`) {
                results.push({ pr: prNumber, action: 'skipped', reason: 'fork' });
                continue;
              }

              // Kill switches
              const labels = pr.labels.map(l => l.name);
              if (labels.includes('automerge:off')) {
                results.push({ pr: prNumber, action: 'skipped', reason: 'automerge:off' });
                continue;
              }
              if (pr.title.includes('[NO-AUTOMERGE]')) {
                results.push({ pr: prNumber, action: 'skipped', reason: '[NO-AUTOMERGE]' });
                continue;
              }

              // Re-validate allowlist/denylist
              const files = [];
              for (let page = 1; ; page++) {
                const resp = await github.rest.pulls.listFiles({
                  owner, repo,
                  pull_number: prNumber,
                  per_page: 100,
                  page,
                });
                files.push(...resp.data.map(f => f.filename));
                if (resp.data.length < 100) break;
              }

              const denyPatterns = [
                /^\.github\/workflows\//,
                /^\.github\/CODEOWNERS$/,
                /^\.github\/dependabot\.ya?ml$/,
                /^pnpm-lock\.yaml$/,
                /^package-lock\.json$/,
                /^yarn\.lock$/,
                /^package\.json$/,
                /^vercel\.json$/,
                /^app\//,
                /^lib\//,
                /^scripts\//,
                /^api\//,
              ];

              let denied = false;
              for (const f of files) {
                for (const pattern of denyPatterns) {
                  if (pattern.test(f)) {
                    denied = true;
                    results.push({ pr: prNumber, action: 'skipped', reason: `denied: ${f}` });
                    break;
                  }
                }
                if (denied) break;
              }
              if (denied) continue;

              // Allowlist v1.1 (extension-constrained)
              const docsExts = /\.(md|mdx|txt|css|json|ya?ml|svg|png|jpe?g|gif)$/;
              const opsExts = /\.(md|mdx|txt|json|ya?ml)$/;
              const rootExts = /\.(md|txt|css)$/;

              function isAllowedSweep(f) {
                if (f.startsWith('docs/') && docsExts.test(f)) return true;
                if (/^[Oo][Pp][Ss]\//i.test(f) && opsExts.test(f)) return true;
                if (f.startsWith('reports/triad/') && f.endsWith('.md')) return true;
                if (rootExts.test(f)) return true;
                if (f.startsWith('.github/ISSUE_TEMPLATE/')) return true;
                if (f === '.github/PULL_REQUEST_TEMPLATE.md') return true;
                if (f.startsWith('.github/') && f.endsWith('.md') && !f.includes('/workflows/')) return true;
                return false;
              }

              let notAllowed = false;
              for (const f of files) {
                if (!isAllowedSweep(f)) {
                  notAllowed = true;
                  results.push({ pr: prNumber, action: 'skipped', reason: `not allowed: ${f}` });
                  break;
                }
              }
              if (notAllowed) continue;

              // Verify required checks (hard gate)
              const requiredChecks = process.env.REQUIRED_CHECKS.split('\n').map(s => s.trim()).filter(Boolean);
              const { repository: gqlRepo } = await github.graphql(`
                query($owner: String!, $repo: String!, $number: Int!) {
                  repository(owner: $owner, name: $repo) {
                    pullRequest(number: $number) {
                      commits(last: 1) {
                        nodes {
                          commit {
                            statusCheckRollup {
                              contexts(first: 100) {
                                nodes {
                                  __typename
                                  ... on CheckRun { name status conclusion }
                                  ... on StatusContext { context state }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              `, { owner, repo, number: prNumber });

              const contexts = gqlRepo.pullRequest.commits.nodes[0]?.commit?.statusCheckRollup?.contexts?.nodes || [];
              let checksOk = true;
              const checksMissing = [];
              const checksFailed = [];

              for (const reqName of requiredChecks) {
                const runs = contexts.filter(c => c.__typename === 'CheckRun' && c.name === reqName);
                if (runs.length > 0) {
                  const last = runs[runs.length - 1];
                  if (last.status !== 'COMPLETED' || last.conclusion !== 'SUCCESS') {
                    checksFailed.push(`${reqName}(${last.status}/${last.conclusion})`);
                    checksOk = false;
                  }
                  continue;
                }
                const ctxs = contexts.filter(c => c.__typename === 'StatusContext' && c.context === reqName);
                if (ctxs.length > 0) {
                  const last = ctxs[ctxs.length - 1];
                  if (last.state !== 'SUCCESS') {
                    checksFailed.push(`${reqName}(${last.state})`);
                    checksOk = false;
                  }
                  continue;
                }
                checksMissing.push(reqName);
                checksOk = false;
              }

              if (!checksOk) {
                results.push({ pr: prNumber, action: 'skipped', reason: `checks_not_ok: missing=[${checksMissing}] failed=[${checksFailed}]` });
                continue;
              }

              // Check merge state
              if (pr.mergeable_state === 'clean') {
                core.info(`PR #${prNumber} is CLEAN; attempting merge.`);
                try {
                  await github.rest.pulls.merge({
                    owner, repo,
                    pull_number: prNumber,
                    merge_method: 'squash',
                  });
                  results.push({ pr: prNumber, action: 'merged', reason: 'CLEAN' });

                  // Delete branch after merge
                  try {
                    await github.rest.git.deleteRef({
                      owner, repo,
                      ref: `heads/${pr.head.ref}`,
                    });
                  } catch (e) {
                    core.info(`Failed to delete branch ${pr.head.ref}: ${e.message}`);
                  }
                } catch (e) {
                  results.push({ pr: prNumber, action: 'failed', reason: e.message });
                }
              } else {
                results.push({ pr: prNumber, action: 'skipped', reason: `state=${pr.mergeable_state}` });
              }
            }

            // Set outputs for summary
            const merged = results.filter(r => r.action === 'merged').length;
            const skipped = results.filter(r => r.action === 'skipped').length;
            const failed = results.filter(r => r.action === 'failed').length;

            core.setOutput('candidates', String(candidates.length));
            core.setOutput('merged', String(merged));
            core.setOutput('skipped', String(skipped));
            core.setOutput('failed', String(failed));
            core.setOutput('details', JSON.stringify(results));

      - name: Write sweep summary
        if: steps.gate.outputs.disabled != 'true'
        run: |
          cat >> "$GITHUB_STEP_SUMMARY" <<EOF
          ## automerge-safe sweep

          | Metric | Count |
          |--------|-------|
          | **Candidates** | ${{ steps.sweep.outputs.candidates }} |
          | **Merged** | ${{ steps.sweep.outputs.merged }} |
          | **Skipped** | ${{ steps.sweep.outputs.skipped }} |
          | **Failed** | ${{ steps.sweep.outputs.failed }} |

          <details><summary>Details</summary>

          \`\`\`json
          ${{ steps.sweep.outputs.details }}
          \`\`\`

          </details>
          EOF
